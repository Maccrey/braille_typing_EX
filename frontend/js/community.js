// Helper function to get the correct API base URL
function getApiBaseUrl() {
    return window.location.hostname === 'localhost' ? 'http://localhost:3001' : 'https://typing.maccrey.com';
}

class CommunityManager {
    constructor() {
        this.currentPage = 1;
        this.totalPages = 1;
        this.currentPost = null;
        this.editingPost = null;
        this.editingComment = null;
        this.init();
    }

    init() {
        this.bindEvents();
    }

    bindEvents() {
        // Create post button
        const createPostBtn = document.getElementById('create-post-btn');
        if (createPostBtn) {
            createPostBtn.addEventListener('click', () => this.showCreatePostModal());
        }

        // Post form
        const postForm = document.getElementById('post-form');
        if (postForm) {
            postForm.addEventListener('submit', (e) => this.handlePostSubmit(e));
        }

        // Modal close buttons
        this.bindModalEvents();

        // Pagination
        this.bindPaginationEvents();
    }

    bindModalEvents() {
        // Post modal
        const postModal = document.getElementById('post-modal');
        const postModalClose = document.getElementById('post-modal-close');
        const postCancelBtn = document.getElementById('post-cancel-btn');

        if (postModalClose) {
            postModalClose.addEventListener('click', () => this.hidePostModal());
        }
        if (postCancelBtn) {
            postCancelBtn.addEventListener('click', () => this.hidePostModal());
        }
        if (postModal) {
            postModal.addEventListener('click', (e) => {
                if (e.target === postModal) this.hidePostModal();
            });
        }

        // Post detail modal
        const postDetailModal = document.getElementById('post-detail-modal');
        const postDetailModalClose = document.getElementById('post-detail-modal-close');

        if (postDetailModalClose) {
            postDetailModalClose.addEventListener('click', () => this.hidePostDetailModal());
        }
        if (postDetailModal) {
            postDetailModal.addEventListener('click', (e) => {
                if (e.target === postDetailModal) this.hidePostDetailModal();
            });
        }
    }

    bindPaginationEvents() {
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');

        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => this.loadPreviousPage());
        }
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => this.loadNextPage());
        }
    }

    async loadPosts(page = 1) {
        const loading = document.getElementById('posts-loading');
        const postsList = document.getElementById('posts-list');
        const emptyMessage = document.getElementById('posts-empty-message');
        const pagination = document.getElementById('posts-pagination');

        try {
            if (loading) loading.style.display = 'block';
            if (postsList) postsList.innerHTML = '';
            if (emptyMessage) emptyMessage.style.display = 'none';
            if (pagination) pagination.style.display = 'none';

            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/posts?page=${page}&limit=10`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                throw new Error('Í≤åÏãúÍ∏ÄÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
            }

            const data = await response.json();
            this.currentPage = data.pagination.currentPage;
            this.totalPages = data.pagination.totalPages;

            if (data.posts.length === 0) {
                if (emptyMessage) emptyMessage.style.display = 'block';
            } else {
                this.renderPosts(data.posts);
                this.updatePagination(data.pagination);
                if (pagination) pagination.style.display = 'flex';
            }

        } catch (error) {
            console.error('Error loading posts:', error);
            this.showError('Í≤åÏãúÍ∏ÄÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
        } finally {
            if (loading) loading.style.display = 'none';
        }
    }

    renderPosts(posts) {
        const postsList = document.getElementById('posts-list');
        if (!postsList) return;

        const userData = localStorage.getItem('userData');
        const currentUser = userData ? JSON.parse(userData).username : null;

        postsList.innerHTML = posts.map(post => {
            const isOwner = currentUser === post.author_name;
            const createdDate = new Date(post.created_at).toLocaleDateString('ko-KR');
            const createdTime = new Date(post.created_at).toLocaleTimeString('ko-KR', {
                hour: '2-digit',
                minute: '2-digit'
            });

            return `
                <div class="post-item" data-post-id="${post.id}">
                    <div class="post-header">
                        <div>
                            <div class="post-title">${this.escapeHtml(post.title)}</div>
                            <div class="post-meta">
                                <span>ÏûëÏÑ±Ïûê: ${this.escapeHtml(post.author_name)}</span>
                                <span>ÏûëÏÑ±Ïùº: ${createdDate} ${createdTime}</span>
                            </div>
                        </div>
                        ${isOwner ? `
                            <div class="owner-post-actions">
                                <button class="edit-post-btn" onclick="communityManager.editPost(${post.id})">
                                    ÏàòÏ†ï
                                </button>
                                <button class="delete-post-btn" onclick="communityManager.deletePost(${post.id})">
                                    ÏÇ≠Ï†ú
                                </button>
                            </div>
                        ` : ''}
                    </div>
                    <div class="post-content collapsed" data-full-content="${this.escapeHtml(post.content)}">${this.escapeHtmlWithLineBreaks(post.content)}</div>
                    <div class="post-actions">
                        <div class="post-stats">
                            <div class="post-stat">
                                <span>üí¨ ÎåìÍ∏Ä ${post.comment_count || 0}Í∞ú</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        // Add click event listeners to post items
        postsList.querySelectorAll('.post-item').forEach(item => {
            // Add expand/collapse functionality for post content
            const postContent = item.querySelector('.post-content');
            if (postContent) {
                postContent.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.togglePostContent(postContent);
                });
            }

            item.addEventListener('click', (e) => {
                // Don't trigger if clicking on action buttons or post content
                if (e.target.closest('.owner-post-actions') || e.target.closest('.post-content')) return;

                const postId = item.dataset.postId;
                this.showPostDetail(postId);
            });
        });
    }

    updatePagination(pagination) {
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const pageInfo = document.getElementById('page-info');

        if (prevPageBtn) {
            prevPageBtn.disabled = !pagination.hasPrev;
        }
        if (nextPageBtn) {
            nextPageBtn.disabled = !pagination.hasNext;
        }
        if (pageInfo) {
            pageInfo.textContent = `${pagination.currentPage} / ${pagination.totalPages}`;
        }
    }

    loadPreviousPage() {
        if (this.currentPage > 1) {
            this.loadPosts(this.currentPage - 1);
        }
    }

    loadNextPage() {
        if (this.currentPage < this.totalPages) {
            this.loadPosts(this.currentPage + 1);
        }
    }

    showCreatePostModal() {
        this.editingPost = null;
        const modal = document.getElementById('post-modal');
        const title = document.getElementById('post-modal-title');
        const submitBtn = document.getElementById('post-submit-btn');
        const postForm = document.getElementById('post-form');

        if (title) title.textContent = 'ÏÉà Í≤åÏãúÍ∏Ä ÏûëÏÑ±';
        if (submitBtn) submitBtn.textContent = 'ÏûëÏÑ±';
        if (postForm) postForm.reset();
        if (modal) modal.style.display = 'block';
    }

    showEditPostModal(post) {
        this.editingPost = post;
        const modal = document.getElementById('post-modal');
        const title = document.getElementById('post-modal-title');
        const submitBtn = document.getElementById('post-submit-btn');
        const postTitle = document.getElementById('post-title');
        const postContent = document.getElementById('post-content');

        if (title) title.textContent = 'Í≤åÏãúÍ∏Ä ÏàòÏ†ï';
        if (submitBtn) submitBtn.textContent = 'ÏàòÏ†ï';
        if (postTitle) postTitle.value = post.title;
        if (postContent) postContent.value = post.content;
        if (modal) modal.style.display = 'block';
    }

    hidePostModal() {
        const modal = document.getElementById('post-modal');
        if (modal) modal.style.display = 'none';
        this.editingPost = null;
    }

    async handlePostSubmit(e) {
        e.preventDefault();

        const title = document.getElementById('post-title').value.trim();
        const content = document.getElementById('post-content').value.trim();

        if (!title || !content) {
            alert('Ï†úÎ™©Í≥º ÎÇ¥Ïö©ÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }

        try {
            const token = localStorage.getItem('authToken');
            const isEdit = this.editingPost !== null;
            const url = isEdit ? `/api/posts/${this.editingPost.id}` : '/api/posts';
            const method = isEdit ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ title, content })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Í≤åÏãúÍ∏Ä Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }

            const responseData = await response.json();

            this.hidePostModal();

            if (isEdit) {
                // ÏàòÏ†ïÎêú Í≤åÏãúÍ∏ÄÏùÑ Î™©Î°ùÏóêÏÑú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏
                this.updatePostInUI(responseData);
            } else {
                // ÏÉà Í≤åÏãúÍ∏ÄÏùÄ Î™©Î°ùÏùÑ Îã§Ïãú Î°úÎìú (Ï≤´ ÌéòÏù¥ÏßÄÎ°ú)
                this.loadPosts(1);
            }

            const successMessage = isEdit ? 'Í≤åÏãúÍ∏ÄÏù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.' : 'Í≤åÏãúÍ∏ÄÏù¥ ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§.';
            this.showSuccess(successMessage);

        } catch (error) {
            console.error('Error submitting post:', error);
            alert(error.message);
        }
    }

    async editPost(postId) {
        try {
            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/posts/${postId}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                throw new Error('Í≤åÏãúÍ∏ÄÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
            }

            const post = await response.json();
            this.showEditPostModal(post);

        } catch (error) {
            console.error('Error loading post for edit:', error);
            alert(error.message);
        }
    }

    // ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑú ÏàòÏ†ï Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú
    editPostFromDetail(postId) {
        this.editPost(postId);
    }

    // ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑú ÏÇ≠Ï†ú Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú
    deletePostFromDetail(postId) {
        if (confirm('Ï†ïÎßêÎ°ú Ïù¥ Í≤åÏãúÍ∏ÄÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
            this.hidePostDetailModal();
            this.deletePost(postId);
        }
    }

    async deletePost(postId) {
        // Î™©Î°ùÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÎê† ÎïåÎßå confirm ÌëúÏãú (ÏÉÅÏÑ∏Î≥¥Í∏∞ÏóêÏÑúÎäî Ïù¥ÎØ∏ confirmÏùÑ ÌñàÏúºÎØÄÎ°ú)
        if (!this.currentPost && !confirm('Ï†ïÎßêÎ°ú Ïù¥ Í≤åÏãúÍ∏ÄÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
            return;
        }

        try {
            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/posts/${postId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Í≤åÏãúÍ∏Ä ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }

            // ÌôîÎ©¥ÏóêÏÑú Í≤åÏãúÍ∏Ä Ï¶âÏãú Ï†úÍ±∞
            this.removePostFromUI(postId);
            this.showSuccess('Í≤åÏãúÍ∏ÄÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');

        } catch (error) {
            console.error('Error deleting post:', error);
            alert(error.message);
        }
    }

    async showPostDetail(postId) {
        const modal = document.getElementById('post-detail-modal');
        const container = document.getElementById('post-detail-container');

        try {
            if (container) container.innerHTML = '<div class="loading-indicator"><div class="loading-spinner"></div><p>Í≤åÏãúÍ∏ÄÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</p></div>';
            if (modal) modal.style.display = 'block';

            const token = localStorage.getItem('authToken');

            // Load post details
            const postResponse = await fetch(`${getApiBaseUrl()}/api/posts/${postId}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!postResponse.ok) {
                throw new Error('Í≤åÏãúÍ∏ÄÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
            }

            const post = await postResponse.json();
            this.currentPost = post;

            // Load comments
            const commentsResponse = await fetch(`${getApiBaseUrl()}/api/comments/posts/${postId}`, {
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            const comments = commentsResponse.ok ? await commentsResponse.json() : [];

            this.renderPostDetail(post, comments);

        } catch (error) {
            console.error('Error loading post detail:', error);
            if (container) {
                container.innerHTML = `<div class="error-message">Í≤åÏãúÍ∏ÄÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}</div>`;
            }
        }
    }

    renderPostDetail(post, comments) {
        const container = document.getElementById('post-detail-container');
        if (!container) return;

        const userData = localStorage.getItem('userData');
        const currentUser = userData ? JSON.parse(userData).username : null;
        const isOwner = currentUser === post.author_name;
        const createdDate = new Date(post.created_at).toLocaleDateString('ko-KR');
        const createdTime = new Date(post.created_at).toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
        });

        container.innerHTML = `
            <div class="post-detail-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div>
                        <div class="post-detail-title">${this.escapeHtml(post.title)}</div>
                        <div class="post-detail-meta">
                            <span>ÏûëÏÑ±Ïûê: ${this.escapeHtml(post.author_name)}</span>
                            <span>ÏûëÏÑ±Ïùº: ${createdDate} ${createdTime}</span>
                        </div>
                    </div>
                    ${isOwner ? `
                        <div class="owner-post-actions">
                            <button class="edit-post-btn" onclick="communityManager.editPostFromDetail(${post.id}); communityManager.hidePostDetailModal();">
                                ÏàòÏ†ï
                            </button>
                            <button class="delete-post-btn" onclick="communityManager.deletePostFromDetail(${post.id})">
                                ÏÇ≠Ï†ú
                            </button>
                        </div>
                    ` : ''}
                </div>
            </div>

            <div class="post-detail-body">${this.escapeHtmlWithLineBreaks(post.content)}</div>

            <div class="comments-section">
                <div class="comments-header">
                    <div class="comments-title">ÎåìÍ∏Ä ${comments.length}Í∞ú</div>
                </div>

                <div class="comment-form">
                    <textarea class="comment-input" id="new-comment-input" placeholder="ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî..."></textarea>
                    <div class="comment-actions">
                        <button class="btn btn-primary" onclick="communityManager.addComment()">ÎåìÍ∏Ä ÏûëÏÑ±</button>
                    </div>
                </div>

                <div class="comments-list" id="comments-list">
                    ${this.renderComments(comments)}
                </div>
            </div>
        `;
    }

    renderComments(comments, level = 0) {
        if (!Array.isArray(comments)) return '';

        return comments.map(comment => {
            const userData = localStorage.getItem('userData');
        const currentUser = userData ? JSON.parse(userData).username : null;
            const isOwner = currentUser === comment.author_name;

            const createdDate = new Date(comment.created_at).toLocaleDateString('ko-KR');
            const createdTime = new Date(comment.created_at).toLocaleTimeString('ko-KR', {
                hour: '2-digit',
                minute: '2-digit'
            });

            const childComments = comment.children && comment.children.length > 0
                ? this.renderComments(comment.children, level + 1)
                : '';

            // ÏàòÏ†ï/ÏÇ≠Ï†ú Î≤ÑÌäº HTML ÏÉùÏÑ±
            let ownerButtons = '';
            if (isOwner) {
                ownerButtons = '<button class="comment-action-btn" onclick="communityManager.editComment(' + comment.id + ')">ÏàòÏ†ï</button><button class="comment-action-btn" onclick="communityManager.deleteComment(' + comment.id + ')">ÏÇ≠Ï†ú</button>';
            }

            return `
                <div class="comment-item ${level > 0 ? 'reply' : ''}" data-comment-id="${comment.id}">
                    <div class="comment-header">
                        <span class="comment-author">${this.escapeHtml(comment.author_name)}</span>
                        <span class="comment-date">${createdDate} ${createdTime}</span>
                    </div>
                    <div class="comment-content">${this.escapeHtmlWithLineBreaks(comment.content)}</div>
                    <div class="comment-actions-bar">
                        <button class="comment-action-btn" onclick="communityManager.showReplyForm(${comment.id})">ÎãµÍ∏Ä</button>
                        ${ownerButtons}
                    </div>
                    <div class="reply-form" id="reply-form-${comment.id}" style="display: none;">
                        <textarea class="reply-input" placeholder="ÎãµÍ∏ÄÏùÑ ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî..."></textarea>
                        <div class="comment-actions">
                            <button class="btn btn-secondary btn-cancel" onclick="communityManager.hideReplyForm(${comment.id})">Ï∑®ÏÜå</button>
                            <button class="btn btn-primary" onclick="communityManager.addReply(${comment.id})">ÎãµÍ∏Ä ÏûëÏÑ±</button>
                        </div>
                    </div>
                </div>
                ${childComments}
            `;
        }).join('');
    }

    hidePostDetailModal() {
        const modal = document.getElementById('post-detail-modal');
        if (modal) modal.style.display = 'none';
        this.currentPost = null;
    }

    addCommentToUI(comment) {
        const commentsList = document.getElementById('comments-list');
        if (!commentsList) return;

        // ÏÉà ÎåìÍ∏Ä HTML ÏÉùÏÑ±
        const commentHTML = this.renderSingleComment(comment);

        // ÎåìÍ∏Ä Î™©Î°ùÏóê Ï∂îÍ∞Ä
        commentsList.insertAdjacentHTML('beforeend', commentHTML);
    }

    addReplyToUI(reply, parentCommentId) {
        const parentComment = document.querySelector(`[data-comment-id="${parentCommentId}"]`);
        if (!parentComment) return;

        // ÎãµÍ∏Ä HTML ÏÉùÏÑ±
        const replyHTML = this.renderSingleComment(reply, true);

        // Î∂ÄÎ™® ÎåìÍ∏Ä Îí§Ïóê ÎãµÍ∏Ä Ï∂îÍ∞Ä
        parentComment.insertAdjacentHTML('afterend', replyHTML);
    }

    renderSingleComment(comment, isReply = false) {
        const userData = localStorage.getItem('userData');
        const currentUser = userData ? JSON.parse(userData).username : null;
        const isOwner = currentUser === comment.author_name;
        const createdDate = new Date(comment.created_at).toLocaleDateString('ko-KR');
        const createdTime = new Date(comment.created_at).toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
        });

        // ÏàòÏ†ï/ÏÇ≠Ï†ú Î≤ÑÌäº HTML ÏÉùÏÑ±
        let ownerButtons = '';
        if (isOwner) {
            ownerButtons = '<button class="comment-action-btn" onclick="communityManager.editComment(' + comment.id + ')">ÏàòÏ†ï</button><button class="comment-action-btn" onclick="communityManager.deleteComment(' + comment.id + ')">ÏÇ≠Ï†ú</button>';
        }

        return `
            <div class="comment-item ${isReply ? 'reply' : ''}" data-comment-id="${comment.id}">
                <div class="comment-header">
                    <span class="comment-author">${this.escapeHtml(comment.author_name)}</span>
                    <span class="comment-date">${createdDate} ${createdTime}</span>
                </div>
                <div class="comment-content">${this.escapeHtmlWithLineBreaks(comment.content)}</div>
                <div class="comment-actions-bar">
                    <button class="comment-action-btn" onclick="communityManager.showReplyForm(${comment.id})">ÎãµÍ∏Ä</button>
                    ${ownerButtons}
                </div>
                <div class="reply-form" id="reply-form-${comment.id}" style="display: none;">
                    <textarea class="reply-input" placeholder="ÎãµÍ∏ÄÏùÑ ÏûëÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî..."></textarea>
                    <div class="comment-actions">
                        <button class="btn btn-secondary btn-cancel" onclick="communityManager.hideReplyForm(${comment.id})">Ï∑®ÏÜå</button>
                        <button class="btn btn-primary" onclick="communityManager.addReply(${comment.id})">ÎãµÍ∏Ä ÏûëÏÑ±</button>
                    </div>
                </div>
            </div>
        `;
    }

    updateCommentCount() {
        const commentsTitle = document.querySelector('.comments-title');
        const commentItems = document.querySelectorAll('.comment-item');
        const count = commentItems.length;

        if (commentsTitle) {
            commentsTitle.textContent = `ÎåìÍ∏Ä ${count}Í∞ú`;
        }
    }

    removeCommentFromUI(commentId) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (commentElement) {
            // ÎãµÍ∏ÄÎì§ÎèÑ Ìï®Íªò Ï∞æÏïÑÏÑú Ï†úÍ±∞
            const replies = this.findReplies(commentElement);
            replies.forEach(reply => reply.remove());

            // ÏõêÎ≥∏ ÎåìÍ∏Ä Ï†úÍ±∞
            commentElement.remove();
        }
    }

    findReplies(commentElement) {
        const replies = [];
        let nextElement = commentElement.nextElementSibling;

        while (nextElement && nextElement.classList.contains('reply')) {
            replies.push(nextElement);
            nextElement = nextElement.nextElementSibling;
        }

        return replies;
    }

    removePostFromUI(postId) {
        const postElement = document.querySelector(`[data-post-id="${postId}"]`);
        if (postElement) {
            postElement.remove();

            // Í≤åÏãúÍ∏ÄÏù¥ ÏóÜÏúºÎ©¥ Îπà Î©îÏãúÏßÄ ÌëúÏãú
            const postsList = document.getElementById('posts-list');
            const emptyMessage = document.getElementById('posts-empty-message');

            if (postsList && postsList.children.length === 0) {
                if (emptyMessage) emptyMessage.style.display = 'block';
            }
        }
    }

    updatePostInUI(updatedPost) {
        const postElement = document.querySelector(`[data-post-id="${updatedPost.id}"]`);
        if (postElement) {
            // Ï†úÎ™©Í≥º Î©îÌÉÄ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            const titleElement = postElement.querySelector('.post-title');
            const contentElement = postElement.querySelector('.post-content');

            if (titleElement) {
                titleElement.textContent = updatedPost.title;
            }

            if (contentElement) {
                // Ï†ÑÏ≤¥ ÎÇ¥Ïö©ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ≥† collapsed ÏÉÅÌÉúÎ°ú ÏÑ§Ï†ï
                contentElement.innerHTML = this.escapeHtmlWithLineBreaks(updatedPost.content);
                contentElement.setAttribute('data-full-content', this.escapeHtml(updatedPost.content));
                contentElement.className = 'post-content collapsed';

                // ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ïû¨ÏÑ§Ï†ï
                contentElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.togglePostContent(contentElement);
                });
            }
        }
    }

    async addComment() {
        const input = document.getElementById('new-comment-input');
        const content = input.value.trim();

        if (!content) {
            alert('ÎåìÍ∏Ä ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }

        try {
            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/comments/posts/${this.currentPost.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ content })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'ÎåìÍ∏Ä ÏûëÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }

            const newComment = await response.json();

            // ÏûÖÎ†• ÌïÑÎìú Ï¥àÍ∏∞Ìôî
            input.value = '';

            // ÏÉà ÎåìÍ∏ÄÏùÑ ÌôîÎ©¥Ïóê Ï¶âÏãú Ï∂îÍ∞Ä
            this.addCommentToUI(newComment);

            // ÎåìÍ∏Ä Ïàò ÏóÖÎç∞Ïù¥Ìä∏
            this.updateCommentCount();

        } catch (error) {
            console.error('Error adding comment:', error);
            alert(error.message);
        }
    }

    showReplyForm(commentId) {
        const replyForm = document.getElementById(`reply-form-${commentId}`);
        if (replyForm) {
            replyForm.style.display = 'block';
        }
    }

    hideReplyForm(commentId) {
        const replyForm = document.getElementById(`reply-form-${commentId}`);
        if (replyForm) {
            replyForm.style.display = 'none';
            const textarea = replyForm.querySelector('.reply-input');
            if (textarea) textarea.value = '';
        }
    }

    async addReply(parentCommentId) {
        const replyForm = document.getElementById(`reply-form-${parentCommentId}`);
        const textarea = replyForm.querySelector('.reply-input');
        const content = textarea.value.trim();

        if (!content) {
            alert('ÎãµÍ∏Ä ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }

        try {
            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/comments/posts/${this.currentPost.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                    content,
                    parentCommentId
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'ÎãµÍ∏Ä ÏûëÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }

            const newReply = await response.json();

            // ÎãµÍ∏Ä Ìèº Ïà®Í∏∞Í∏∞
            this.hideReplyForm(parentCommentId);

            // ÏÉà ÎãµÍ∏ÄÏùÑ ÌôîÎ©¥Ïóê Ï¶âÏãú Ï∂îÍ∞Ä
            this.addReplyToUI(newReply, parentCommentId);

            // ÎåìÍ∏Ä Ïàò ÏóÖÎç∞Ïù¥Ìä∏
            this.updateCommentCount();

        } catch (error) {
            console.error('Error adding reply:', error);
            alert(error.message);
        }
    }

    editComment(commentId) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        const contentElement = commentElement.querySelector('.comment-content');
        const actionsBar = commentElement.querySelector('.comment-actions-bar');
        const currentContent = contentElement.textContent;

        // ÏõêÎ≥∏ ÎÇ¥Ïö©ÏùÑ Îç∞Ïù¥ÌÑ∞ ÏÜçÏÑ±Ïóê Ï†ÄÏû•
        commentElement.dataset.originalContent = currentContent;

        // ÏàòÏ†ï Î™®Îìú ÌÅ¥ÎûòÏä§ Ï∂îÍ∞Ä
        commentElement.classList.add('editing');

        // Í∏∞Ï°¥ Ïï°ÏÖò Î≤ÑÌäºÎì§ Ïà®Í∏∞Í∏∞
        if (actionsBar) {
            actionsBar.style.display = 'none';
            // Ï∂îÍ∞Ä ÌôïÏã§ÏÑ±ÏùÑ ÏúÑÌï¥
            actionsBar.style.visibility = 'hidden';
        }

        console.log('Edit mode: hiding actions bar', actionsBar);

        // Ìé∏Ïßë ÌèºÏúºÎ°ú ÍµêÏ≤¥
        contentElement.innerHTML = `
            <div class="comment-edit-form">
                <textarea class="comment-edit-input">${this.escapeHtml(currentContent)}</textarea>
                <div class="comment-edit-actions">
                    <button class="btn btn-secondary btn-sm" onclick="communityManager.cancelEditComment(${commentId})">Ï∑®ÏÜå</button>
                    <button class="btn btn-primary btn-sm" onclick="communityManager.saveEditComment(${commentId})">Ï†ÄÏû•</button>
                </div>
            </div>
        `;

        // textarea ÏûêÎèô Î¶¨ÏÇ¨Ïù¥Ïßï ÏÑ§Ï†ï
        const textarea = contentElement.querySelector('.comment-edit-input');
        if (textarea) {
            this.setupAutoResize(textarea);
        }
    }

    cancelEditComment(commentId) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        const originalContent = commentElement.dataset.originalContent;
        const contentElement = commentElement.querySelector('.comment-content');
        const actionsBar = commentElement.querySelector('.comment-actions-bar');

        // ÏõêÎ≥∏ ÎÇ¥Ïö©ÏúºÎ°ú Î≥µÏõê
        contentElement.textContent = originalContent;

        // ÏàòÏ†ï Î™®Îìú ÌÅ¥ÎûòÏä§ Ï†úÍ±∞
        commentElement.classList.remove('editing');

        // Ïï°ÏÖò Î≤ÑÌäºÎì§ Îã§Ïãú Î≥¥Ïù¥Í∏∞
        if (actionsBar) {
            actionsBar.style.display = 'flex';
            actionsBar.style.visibility = 'visible';
        }

        console.log('Cancel edit: showing actions bar', actionsBar);
    }

    async saveEditComment(commentId) {
        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
        if (!commentElement) return;

        const textarea = commentElement.querySelector('.comment-edit-input');
        const newContent = textarea.value.trim();

        if (!newContent) {
            alert('ÎåìÍ∏Ä ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }

        try {
            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/comments/${commentId}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    content: newContent
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'ÎåìÍ∏Ä ÏàòÏ†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }

            // ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏàòÏ†ïÎêòÎ©¥ ÎÇ¥Ïö© ÏóÖÎç∞Ïù¥Ìä∏
            const contentElement = commentElement.querySelector('.comment-content');
            const actionsBar = commentElement.querySelector('.comment-actions-bar');

            contentElement.innerHTML = this.escapeHtmlWithLineBreaks(newContent);

            // ÏàòÏ†ï Î™®Îìú ÌÅ¥ÎûòÏä§ Ï†úÍ±∞
            commentElement.classList.remove('editing');

            // Ïï°ÏÖò Î≤ÑÌäºÎì§ Îã§Ïãú Î≥¥Ïù¥Í∏∞
            if (actionsBar) {
                actionsBar.style.display = 'flex';
                actionsBar.style.visibility = 'visible';
            }

            console.log('Save edit: showing actions bar', actionsBar);

        } catch (error) {
            console.error('Error editing comment:', error);
            alert('ÎåìÍ∏Ä ÏàòÏ†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ' + error.message);
        }
    }

    async deleteComment(commentId) {
        if (!confirm('Ï†ïÎßêÎ°ú Ïù¥ ÎåìÍ∏ÄÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
            return;
        }

        try {
            const token = localStorage.getItem('authToken');
            const response = await fetch(`${getApiBaseUrl()}/api/comments/${commentId}`, {
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'ÎåìÍ∏Ä ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }

            // ÌôîÎ©¥ÏóêÏÑú ÎåìÍ∏Ä Ï†úÍ±∞
            this.removeCommentFromUI(commentId);

            // ÎåìÍ∏Ä Ïàò ÏóÖÎç∞Ïù¥Ìä∏
            this.updateCommentCount();

        } catch (error) {
            console.error('Error deleting comment:', error);
            alert(error.message);
        }
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    escapeHtmlWithLineBreaks(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML.replace(/\n/g, '<br>');
    }

    togglePostContent(postContent) {
        const isCollapsed = postContent.classList.contains('collapsed');

        if (isCollapsed) {
            // Expand
            postContent.classList.remove('collapsed');
            postContent.classList.add('expanded');
        } else {
            // Collapse
            postContent.classList.remove('expanded');
            postContent.classList.add('collapsed');
        }
    }

    showError(message) {
        const errorDiv = document.getElementById('error-message');
        if (errorDiv) {
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
    }

    showSuccess(message) {
        // You can implement a success message display here
        alert(message);
    }

    setupAutoResize(textarea) {
        // ÎÜíÏù¥ ÏûêÎèô Ï°∞Ï†à Ìï®Ïàò
        const adjustHeight = () => {
            // ÎÜíÏù¥Î•º autoÎ°ú Î¶¨ÏÖãÌïòÏó¨ Ïã§Ï†ú ÎÇ¥Ïö© ÎÜíÏù¥ Ï∏°Ï†ï
            textarea.style.height = 'auto';

            // Ïä§ÌÅ¨Î°§ ÎÜíÏù¥ Í∏∞Î∞òÏúºÎ°ú ÏÉàÎ°úÏö¥ ÎÜíÏù¥ Í≥ÑÏÇ∞ (ÏõêÎûò ÌÅ¨Í∏∞Î°ú Î≥µÏõê)
            const newHeight = Math.max(20, Math.min(60, textarea.scrollHeight));
            textarea.style.height = newHeight + 'px';
        };

        // Ï¶âÏãú ÎÜíÏù¥ Ï°∞Ï†à
        setTimeout(adjustHeight, 0);

        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎì§
        textarea.addEventListener('input', adjustHeight);
        textarea.addEventListener('paste', () => setTimeout(adjustHeight, 10));
        textarea.addEventListener('keydown', () => setTimeout(adjustHeight, 0));
    }
}

// Initialize community manager
let communityManager;

// Initialize when the page loads
document.addEventListener('DOMContentLoaded', () => {
    communityManager = new CommunityManager();
});